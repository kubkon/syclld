# SYCL 2023 - Linker Workshop

This repo contains the source code and actual instructions for participating in the SYCL 2023
Linker Workshop in Vancouver.

## Part 1

In the first part of the workshop, we will learn how to parse input relocatable object files.
For each object file, we will create a set of input atoms (per each input section), and a set of 
input symbols (according to the object's symbol table).

Objectives:
* understand the format of the ELF file
* understand the concept of a section header (`shdr`)
* understand the concept of a symbol table
* parse section headers into atoms
* parse input symbol table into lists of locals and globals

## Part 2

Now that we know how to parse object files, it is time to resolve the globals into a unique
set of symbols. Normally, they can either be defined in an input relocatable object file,
shared object, or defined by the linker (the so-called synthetic symbols). In our case, since
we do not link against any shared objects, globals have to either be defined in an input
relocatable object file or by the linker iself.

Objectives:
* understand the concept of symbol binding (linkage): local, weak and global
* understand the concept of symbol duplicates and how to handle this
* learn about some synthetic symbols that need to be generated by the linker such as `_DYNAMIC`
* implement the symbol resolver for symbols defined in the relocatable object files
* implement logic responsible for detecting symbol duplicates

## Part 3

Some relocations as generated by the compiler will require the existence of an indirection via a pointer in a
global offset table (GOT). In this part of the workshop, we will learn how to scan the relocations for each
parsed section and create such pointers.

Objectives:
* understand the concept of a relocation type: `R_X86_64_64`, `R_x86_64_GOTPCREL`, etc.
* scan reloctions in each parsed input section and create a GOT pointer for each encountered relocation that
  requires it

## Part 4

Initialize output sections, sort them and initialize required segments.
Create program headers combining multiple matching sections into a single segment sharing the same permission
attributes.

Objectives:
* understand section precedence and its implications on the number of loadable segments

## Part 5

By this point, we have the information necessary to allocate symbols in each output section relative to the 
start address of that section, and its size. In other words, we do not create the final allocation in virtual
memory yet, but instead work out partial offsets that are to be correctly aligned within the output section.

Objectives:
* understand the concept of alignment in memory
* understand that GOT is a special, synthetic section and doesn't need to get symbols allocated
* build a list of all symbols in each output section correctly allocated wrt to the start of the said section

## Part 6

Allocate loadable segments in virtual memory and then allocate output sections, atoms, and symbols.
allocate output sections in virtual memory. 

Objectives:
* understand the concept of memory permission in a loadable (`alloc`) segment
* build a list of program headers, section headers, and output sections fully allocated in virtual memory

## Part 7

For each output section, resolve relocations and commit to a file.

Objectives:
* understand the format of a relocation type (`Elf64_Rela`)
* understand how to correctly resolve each relocation type
* write the resolved chunks to the output file at the correct file offsets

## Part 8

Commit string tables, header, program and section headers to a file.

Objectives:
* create a valid ELF header
* commit program and section headers in appropriate locations within the file

