//! Elf is the driver - it coordinates which stage in the link process should be next executed
//! and produces/flushes the final output executable file.

allocator: Allocator,

/// Options parsed from the linker link.
options: Options,

/// Output file descriptor/handle.
file: std.fs.File,

/// Offset in the file into the output section headers table.
shoff: u64 = 0,

/// List of input static archives from the linker line.
archives: std.ArrayListUnmanaged(Archive) = .{},

/// List of input relocatable object files either from the linker line, or
/// extracted from an archive.
objects: std.ArrayListUnmanaged(Object) = .{},

/// List of output program headers.
phdrs: std.ArrayListUnmanaged(elf.Elf64_Phdr) = .{},

/// List of output sections.
sections: std.MultiArrayList(Section) = .{},

/// Index of the PHDR program header.
phdr_seg_index: ?u16 = null,
/// Index of the read-only loadable segment.
load_r_seg_index: ?u16 = null,
/// Index of the read-execute loadable segment.
load_re_seg_index: ?u16 = null,
/// Index of the read-write loadable segment.
load_rw_seg_index: ?u16 = null,

/// Index of the .text section.
text_sect_index: ?u16 = null,
/// Index of the .got section.
got_sect_index: ?u16 = null,
/// Index of the .symtab section.
symtab_sect_index: ?u16 = null,
/// Index of the .strtab section.
strtab_sect_index: ?u16 = null,
/// Index of the .shstrtab section.
shstrtab_sect_index: ?u16 = null,

/// Internal linker state for coordinating symbol resolution and synthetics
internal_object: ?InternalObject = null,
/// Index of the _DYNAMIC symbol.
dynamic_index: ?u32 = null,
/// Index of the init_array_start symbol.
init_array_start_index: ?u32 = null,
/// Index of the init_array_end symbol.
init_array_end_index: ?u32 = null,
/// Index of the fini_array_start symbol.
fini_array_start_index: ?u32 = null,
/// Index of the fini_array_end symbol.
fini_array_end_index: ?u32 = null,
/// Index of the _GLOBAL_OFFSET_TABLE symbol.
got_index: ?u32 = null,

/// Index of the entrypoint symbol.
entry_index: ?u32 = null,

/// List of global symbols.
/// Each relocatable object file references these symbols by index
/// in their respective globals symbol tables.
globals: std.ArrayListUnmanaged(Symbol) = .{},
/// Table of globals indexed by symbol name.
globals_table: std.StringHashMapUnmanaged(u32) = .{},

/// Temporary, global string interning table.
string_intern: StringTable(.string_intern) = .{},

/// Output SHDR string table.
/// This is where we store names of each SHDR.
shstrtab: StringTable(.shstrtab) = .{},
/// Output symbol string table.
strtab: StringTable(.strtab) = .{},
/// Output symbol table.
symtab: std.ArrayListUnmanaged(elf.Elf64_Sym) = .{},

/// Synthetic GOT section.
got_section: SyntheticSection(u32, *Elf, .{
    .log_scope = .got_section,
    .entry_size = @sizeOf(u64),
    .baseAddrFn = Elf.getGotBaseAddress,
    .writeFn = Elf.writeGotEntry,
}) = .{},

/// List of all Atoms.
/// Each relocatable object file references an Atom indirectly via Atom.Index.
atoms: std.ArrayListUnmanaged(Atom) = .{},

/// List of all warnings generated by the linker.
warnings: std.ArrayListUnmanaged([]const u8) = .{},
/// List of all errors generated by the linker.
errors: std.ArrayListUnmanaged([]const u8) = .{},

pub const Emit = struct {
    directory: std.fs.Dir,
    sub_path: []const u8,
};

const Options = struct {
    positionals: []const []const u8,
    libs: []const []const u8,
    lib_dirs: []const []const u8,
    emit: Emit,
};

const Section = struct {
    shdr: elf.Elf64_Shdr,
    phdr: ?u16,
    first_atom: ?Atom.Index,
    last_atom: ?Atom.Index,
};

const default_base_addr: u64 = 0x200000;
const default_page_size: u64 = 0x1000;

pub fn openPath(allocator: Allocator, options: Options) !*Elf {
    const file = try options.emit.directory.createFile(options.emit.sub_path, .{
        .truncate = true,
        .read = true,
        .mode = if (builtin.os.tag == .windows) 0 else 0o777,
    });
    errdefer file.close();

    const self = try createEmpty(allocator, options);
    errdefer allocator.destroy(self);

    self.file = file;

    return self;
}

fn createEmpty(gpa: Allocator, options: Options) !*Elf {
    const self = try gpa.create(Elf);

    self.* = .{
        .allocator = gpa,
        .file = undefined,
        .options = options,
    };

    return self;
}

pub fn deinit(self: *Elf) void {
    const gpa = self.allocator;
    self.string_intern.deinit(gpa);
    self.symtab.deinit(gpa);
    self.shstrtab.deinit(gpa);
    self.strtab.deinit(gpa);
    self.atoms.deinit(gpa);
    self.globals.deinit(gpa);
    self.globals_table.deinit(gpa);
    self.got_section.deinit(gpa);
    self.phdrs.deinit(gpa);
    self.sections.deinit(gpa);
    for (self.objects.items) |*object| {
        object.deinit(gpa);
    }
    self.objects.deinit(gpa);
    for (self.archives.items) |*archive| {
        archive.file.close();
        archive.deinit(gpa);
    }
    self.archives.deinit(gpa);
    if (self.internal_object) |*object| {
        object.deinit(gpa);
    }
    self.warnings.deinit(gpa);
    self.errors.deinit(gpa);
}

fn resolveLib(
    arena: Allocator,
    search_dirs: []const []const u8,
    name: []const u8,
    ext: []const u8,
) !?[]const u8 {
    const search_name = try std.fmt.allocPrint(arena, "lib{s}{s}", .{ name, ext });

    for (search_dirs) |dir| {
        const full_path = try fs.path.join(arena, &[_][]const u8{ dir, search_name });

        // Check if the file exists.
        const tmp = fs.cwd().openFile(full_path, .{}) catch |err| switch (err) {
            error.FileNotFound => continue,
            else => |e| return e,
        };
        defer tmp.close();

        return full_path;
    }

    return null;
}

pub fn flush(self: *Elf) !void {
    const gpa = self.allocator;

    var arena_allocator = std.heap.ArenaAllocator.init(gpa);
    defer arena_allocator.deinit();
    const arena = arena_allocator.allocator();

    var lib_dirs = std.ArrayList([]const u8).init(arena);
    for (self.options.lib_dirs) |dir| {
        // Verify that search path actually exists
        var tmp = fs.cwd().openDir(dir, .{}) catch |err| switch (err) {
            error.FileNotFound => {
                self.warn("Library search directory not found for '-L{s}'", .{dir});
                continue;
            },
            else => |e| return e,
        };
        defer tmp.close();

        try lib_dirs.append(dir);
    }

    var libs = std.StringArrayHashMap([]const u8).init(arena);
    var lib_not_found = false;
    for (self.options.libs) |lib_name| {
        if (try resolveLib(arena, lib_dirs.items, lib_name, ".a")) |full_path| {
            _ = try libs.getOrPut(full_path);
        } else {
            self.warn("Library not found for '-l{s}'", .{lib_name});
            lib_not_found = true;
        }
    }
    if (lib_not_found and lib_dirs.items.len > 0) {
        self.warn("Library search paths:", .{});
        for (lib_dirs.items) |dir| {
            self.warn("  {s}", .{dir});
        }
    }

    var positionals = std.ArrayList([]const u8).init(arena);
    try positionals.ensureTotalCapacity(self.options.positionals.len);
    for (self.options.positionals) |obj| {
        positionals.appendAssumeCapacity(obj);
    }

    // Append empty string to string tables.
    try self.string_intern.buffer.append(gpa, 0);
    try self.strtab.buffer.append(gpa, 0);
    try self.shstrtab.buffer.append(gpa, 0);
    // Append null section.
    _ = try self.addSection(.{ .name = "" });
    // Append null atom.
    try self.atoms.append(gpa, .{});

    try self.parsePositionals(positionals.items);
    try self.parseLibs(libs.keys());

    self.internal_object = InternalObject{};

    try self.resolveSymbols();

    // Set the entrypoint if found
    self.entry_index = self.globals_table.get("_start") orelse null;
    if (self.entry_index == null) self.fatal("no entrypoint found: '_start'", .{});

    self.checkDuplicates();
    self.reportWarningsAndErrorsAndExit();

    try self.resolveSyntheticSymbols();

    try self.initSections();
    try self.sortSections();
    try self.initSegments();

    self.checkUndefined();
    self.reportWarningsAndErrorsAndExit();

    try self.calcSectionSizes();
    self.allocateSegments();
    self.allocateAllocSections();
    self.allocateAtoms();
    self.allocateLocals();
    self.allocateGlobals();
    self.allocateSyntheticSymbols();

    try self.setSymtab();
    self.setShstrtab();
    self.allocateNonAllocSections();

    self.shoff = blk: {
        // TODO: work out at what offset we write the SHDRs in the file
        break :blk 0;
    };

    state_log.debug("{}", .{self.dumpState()});

    try self.writeAtoms();
    try self.writeSyntheticSections();
    try self.writePhdrs();
    try self.writeSymtab();
    try self.writeStrtab();
    try self.writeShStrtab();
    try self.writeShdrs();
    try self.writeHeader();

    self.reportWarningsAndErrorsAndExit();
}

fn initSections(self: *Elf) !void {
    for (self.atoms.items[1..]) |*atom| {
        try atom.initOutputSection(self);
    }

    if (self.got_section.count() > 0) {
        self.got_sect_index = try self.addSection(.{
            .name = ".got",
            .type = elf.SHT_PROGBITS,
            .flags = elf.SHF_ALLOC | elf.SHF_WRITE,
            .addralign = @alignOf(u64),
        });
    }

    self.shstrtab_sect_index = try self.addSection(.{
        .name = ".shstrtab",
        .type = elf.SHT_STRTAB,
        .entsize = 1,
        .addralign = 1,
    });

    self.strtab_sect_index = try self.addSection(.{
        .name = ".strtab",
        .type = elf.SHT_STRTAB,
        .entsize = 1,
        .addralign = 1,
    });
    self.symtab_sect_index = try self.addSection(.{
        .name = ".symtab",
        .type = elf.SHT_SYMTAB,
        .link = self.strtab_sect_index.?,
        .addralign = @alignOf(elf.Elf64_Sym),
        .entsize = @sizeOf(elf.Elf64_Sym),
    });
}

fn calcSectionSizes(self: *Elf) !void {
    for (self.atoms.items[1..], 1..) |*atom, atom_index| {
        _ = atom;
        _ = atom_index;
        // TODO: each Atom will have output section already assigned
        // for each Atom, we get the output section and append the Atom to the section's
        // linked-list of Atoms, and simultaneously we work out a relative offset
        // of each Atom within each section assuming that each section starts at address of 0.
    }

    if (self.got_sect_index) |index| {
        const shdr = &self.sections.items(.shdr)[index];
        shdr.sh_size = self.got_section.size();
        shdr.sh_addralign = @sizeOf(u64);
    }
}

fn getSectionRank(self: *Elf, shdr: elf.Elf64_Shdr) u4 {
    const flags = shdr.sh_flags;
    switch (shdr.sh_type) {
        elf.SHT_NULL => return 0,
        elf.SHT_PREINIT_ARRAY,
        elf.SHT_INIT_ARRAY,
        elf.SHT_FINI_ARRAY,
        => return 2,
        elf.SHT_PROGBITS => if (flags & elf.SHF_ALLOC != 0) {
            if (flags & elf.SHF_EXECINSTR != 0) {
                return 2;
            } else if (flags & elf.SHF_WRITE != 0) {
                return if (flags & elf.SHF_TLS != 0) 3 else 5;
            } else {
                return 1;
            }
        } else {
            const name = self.shstrtab.getAssumeExists(shdr.sh_name);
            if (mem.startsWith(u8, name, ".debug")) {
                return 7;
            } else {
                return 8;
            }
        },
        elf.SHT_NOBITS => return if (flags & elf.SHF_TLS != 0) 4 else 6,
        elf.SHT_SYMTAB => return 0xa,
        elf.SHT_STRTAB => return 0xb,
        else => return 0xf,
    }
}

fn sortSections(self: *Elf) !void {
    const Entry = struct {
        shndx: u16,

        pub fn get(this: @This(), elf_file: *Elf) elf.Elf64_Shdr {
            return elf_file.sections.items(.shdr)[this.shndx];
        }

        pub fn lessThan(elf_file: *Elf, lhs: @This(), rhs: @This()) bool {
            return elf_file.getSectionRank(lhs.get(elf_file)) < elf_file.getSectionRank(rhs.get(elf_file));
        }
    };

    const gpa = self.allocator;

    var entries = try std.ArrayList(Entry).initCapacity(gpa, self.sections.slice().len);
    defer entries.deinit();
    for (0..self.sections.slice().len) |shndx| {
        entries.appendAssumeCapacity(.{ .shndx = @intCast(u16, shndx) });
    }

    std.mem.sort(Entry, entries.items, self, Entry.lessThan);

    const backlinks = try gpa.alloc(u16, entries.items.len);
    defer gpa.free(backlinks);
    for (entries.items, 0..) |entry, i| {
        backlinks[entry.shndx] = @intCast(u16, i);
    }

    var slice = self.sections.toOwnedSlice();
    defer slice.deinit(gpa);

    try self.sections.ensureTotalCapacity(gpa, slice.len);
    for (entries.items) |sorted| {
        self.sections.appendAssumeCapacity(slice.get(sorted.shndx));
    }

    for (self.atoms.items[1..]) |*atom| {
        atom.out_shndx = backlinks[atom.out_shndx];
    }

    for (&[_]*?u16{
        &self.text_sect_index,
        &self.got_sect_index,
        &self.symtab_sect_index,
        &self.strtab_sect_index,
        &self.shstrtab_sect_index,
    }) |maybe_index| {
        if (maybe_index.*) |*index| {
            index.* = backlinks[index.*];
        }
    }

    if (self.symtab_sect_index) |index| {
        const shdr = &self.sections.items(.shdr)[index];
        shdr.sh_link = self.strtab_sect_index.?;
    }
}

fn initSegments(self: *Elf) !void {
    // Add PHDR segment
    {
        const offset = @sizeOf(elf.Elf64_Ehdr);
        self.phdr_seg_index = try self.addSegment(.{
            .type = elf.PT_PHDR,
            .flags = elf.PF_R,
            .@"align" = @alignOf(elf.Elf64_Phdr),
            .offset = offset,
            .addr = default_base_addr + offset,
        });
    }

    // The first loadable segment is always read-only even if there is no
    // read-only section to load. We need a read-only loadable segment
    // to coalesce PHDR segment into together with the Ehdr.
    var last_phdr: u16 = try self.addSegment(.{
        .type = elf.PT_LOAD,
        .flags = elf.PF_R,
        .@"align" = default_page_size,
    });

    // Then, we proceed in creating segments for all alloc sections.
    for (self.sections.items(.shdr)) |shdr| {
        if (shdr.sh_flags & elf.SHF_ALLOC == 0) continue;
        const write = shdr.sh_flags & elf.SHF_WRITE != 0;
        const exec = shdr.sh_flags & elf.SHF_EXECINSTR != 0;
        var flags: u32 = elf.PF_R;
        if (write) flags |= elf.PF_W;
        if (exec) flags |= elf.PF_X;

        const phdr = self.phdrs.items[last_phdr];
        if (phdr.p_flags != flags) {
            last_phdr = try self.addSegment(.{
                .type = elf.PT_LOAD,
                .flags = flags,
                .@"align" = default_page_size,
            });
        }
    }

    var phdr_index = if (self.phdr_seg_index) |index| index + 1 else 0;
    for (self.sections.items(.shdr), 0..) |shdr, i| {
        if (shdr.sh_flags & elf.SHF_ALLOC == 0) continue;
        const write = shdr.sh_flags & elf.SHF_WRITE != 0;
        const exec = shdr.sh_flags & elf.SHF_EXECINSTR != 0;
        var flags: u32 = elf.PF_R;
        if (write) flags |= elf.PF_W;
        if (exec) flags |= elf.PF_X;
        if (self.phdrs.items[phdr_index].p_flags != flags) phdr_index += 1;
        self.sections.items(.phdr)[i] = phdr_index;
    }

    // Backpatch size of the PHDR segment now that we now how many program headers
    // we actually have.
    if (self.phdr_seg_index) |index| {
        const phdr = &self.phdrs.items[index];
        const size = self.phdrs.items.len * @sizeOf(elf.Elf64_Phdr);
        phdr.p_filesz = size;
        phdr.p_memsz = size;
    }
}

fn allocateSegments(self: *Elf) void {
    _ = self;
    // TODO: Now that we have initialized segments, we can go ahead and allocate them in memory.
    // When sorting sections, we ensured that sections sharing permissions (read-only, read-write, etc.)
    // are next to each other. This was so that we could create the minimal number of loadable
    // segments that will cover them.
    // Here, we need to iterate over all segments, calculate their size by accessing all sections
    // that each segment encompasses (minding the alignment of each section), calculate
    // max file and memory alignment of each segment, and allocate.
    // You can use `Elf.getSectionIndexes()` to get a range of section indexes for a given
    // segment index.
    // It is important to note that the first loadable segment has to encompass the PHDR program header.
}

fn allocateAllocSections(self: *Elf) void {
    _ = self;
    // TODO: Here want to allocate each `SHF_ALLOC` section. We can do that as we have allocated each
    // segment in file and memory which we will use as the starting point for working out offset and
    // address of each encompassed section by the segment.
    // For each program header, we iterate the sections it encompasses and allocate them in file and
    // in memory. You can use `Elf.getSectionIndexes()` to get a range of section indexes for a given
    // segment index.
    // It is important to remember that `SHT_NOBITS` sections do not take any space in file, only in
    // memory.
}

fn allocateNonAllocSections(self: *Elf) void {
    _ = self;
    // var offset: u64 = 0;
    // for (self.sections.items(.shdr)) |*shdr| {
    //     defer offset = shdr.sh_offset + shdr.sh_size;

    //     if (shdr.sh_type == elf.SHT_NULL) continue;
    //     if (shdr.sh_flags & elf.SHF_ALLOC != 0) continue;

    //     shdr.sh_offset = mem.alignForwardGeneric(u64, offset, shdr.sh_addralign);
    // }
}

fn allocateAtoms(self: *Elf) void {
    _ = self;
    // TODO: for each section, traverse the list of Atoms it contains, and the section's address
    // to make each Atom's address fully allocated.
}

fn allocateLocals(self: *Elf) void {
    _ = self;
    // TODO: for each object file, traverse all local symbols, get the containing Atom,
    // and add its `Atom.value` to `Symbol.value`.
    // Note that it might happen that there is no Atom for the given local symbol.
    // Can you work out why that may be the case?
}

fn allocateGlobals(self: *Elf) void {
    _ = self;
    // TODO: for each global symbol, get the containing Atom, and add its `Atom.value` to `Symbol.value`.
    // Note that it might happen that there is no Atom for the given global symbol.
    // Can you work out why that may be the case?
}

fn allocateSyntheticSymbols(self: *Elf) void {
    if (self.dynamic_index) |index| {
        if (self.got_sect_index) |got_index| {
            const shdr = self.sections.items(.shdr)[got_index];
            self.getGlobal(index).value = shdr.sh_addr;
        }
    }
    if (self.init_array_start_index) |index| {
        const global = self.getGlobal(index);
        if (self.text_sect_index) |text_index| {
            global.shndx = text_index;
        }
        if (self.entry_index) |entry_index| {
            global.value = self.getGlobal(entry_index).value;
        }
    }
    if (self.init_array_end_index) |index| {
        const global = self.getGlobal(index);
        if (self.text_sect_index) |text_index| {
            global.shndx = text_index;
        }
        if (self.entry_index) |entry_index| {
            global.value = self.getGlobal(entry_index).value;
        }
    }
    if (self.fini_array_start_index) |index| {
        const global = self.getGlobal(index);
        if (self.text_sect_index) |text_index| {
            global.shndx = text_index;
        }
        if (self.entry_index) |entry_index| {
            global.value = self.getGlobal(entry_index).value;
        }
    }
    if (self.fini_array_end_index) |index| {
        const global = self.getGlobal(index);
        if (self.text_sect_index) |text_index| {
            global.shndx = text_index;
        }
        if (self.entry_index) |entry_index| {
            global.value = self.getGlobal(entry_index).value;
        }
    }
    if (self.got_index) |index| {
        if (self.got_sect_index) |sect_index| {
            const shdr = self.sections.items(.shdr)[sect_index];
            self.getGlobal(index).value = shdr.sh_addr;
        }
    }
}

fn parsePositionals(self: *Elf, files: []const []const u8) !void {
    for (files) |file_name| {
        const full_path = full_path: {
            var buffer: [fs.MAX_PATH_BYTES]u8 = undefined;
            const path = std.fs.realpath(file_name, &buffer) catch |err| switch (err) {
                error.FileNotFound => {
                    self.fatal("file not found '{s}'", .{file_name});
                    continue;
                },
                else => |e| return e,
            };
            break :full_path try self.allocator.dupe(u8, path);
        };
        defer self.allocator.free(full_path);
        log.debug("parsing input file path '{s}'", .{full_path});

        if (try self.parseObject(full_path)) continue;
        if (try self.parseArchive(full_path)) continue;

        self.warn("unknown filetype for positional input file: '{s}'", .{file_name});
    }
}

fn parseLibs(self: *Elf, libs: []const []const u8) !void {
    for (libs) |lib| {
        log.debug("parsing lib path '{s}'", .{lib});
        if (try self.parseArchive(lib)) continue;

        self.warn("unknown filetype for a library: '{s}'", .{lib});
    }
}

fn parseObject(self: *Elf, path: []const u8) !bool {
    const gpa = self.allocator;
    const file = fs.cwd().openFile(path, .{}) catch |err| switch (err) {
        error.FileNotFound => return false,
        else => |e| return e,
    };
    defer file.close();

    const header = try file.reader().readStruct(elf.Elf64_Ehdr);
    try file.seekTo(0);

    if (!Object.isValidHeader(&header)) return false;

    const file_stat = try file.stat();
    const file_size = math.cast(usize, file_stat.size) orelse return error.Overflow;
    const data = try file.readToEndAlloc(gpa, file_size);

    const object_id = @intCast(u32, self.objects.items.len);
    const object = try self.objects.addOne(gpa);
    object.* = .{
        .name = try gpa.dupe(u8, path),
        .data = data,
        .object_id = object_id,
    };
    try object.parse(self);

    return true;
}

fn parseArchive(self: *Elf, path: []const u8) !bool {
    const gpa = self.allocator;
    const file = fs.cwd().openFile(path, .{}) catch |err| switch (err) {
        error.FileNotFound => return false,
        else => |e| return e,
    };
    errdefer file.close();

    const magic = try file.reader().readBytesNoEof(Archive.SARMAG);
    try file.seekTo(0);

    if (!Archive.isValidMagic(&magic)) return false;

    const archive = try self.archives.addOne(gpa);
    archive.* = .{
        .name = try gpa.dupe(u8, path),
        .file = file,
    };
    try archive.parse(gpa, self);

    return true;
}

fn resolveSymbols(self: *Elf) !void {
    for (self.objects.items) |object| {
        try object.resolveSymbols(self);
    }
    try self.resolveSymbolsInArchives();
}

fn resolveSymbolsInArchives(self: *Elf) !void {
    if (self.archives.items.len == 0) return;

    var next_sym: usize = 0;
    loop: while (next_sym < self.globals.items.len) {
        const global = self.globals.items[next_sym];
        const global_name = global.getName(self);
        if (global.isUndef(self)) for (self.archives.items) |archive| {
            // Check if the entry exists in a static archive.
            const offsets = archive.toc.get(global_name) orelse {
                // No hit.
                continue;
            };
            assert(offsets.items.len > 0);

            const extracted = archive.getObject(offsets.items[0], self) catch |err| switch (err) {
                error.InvalidHeader => continue,
                else => |e| return e,
            };

            const object_id = @intCast(u16, self.objects.items.len);
            const object = try self.objects.addOne(self.allocator);
            object.* = extracted;
            object.object_id = object_id;
            try object.parse(self);
            try object.resolveSymbols(self);

            continue :loop;
        };

        next_sym += 1;
    }
}

fn resolveSyntheticSymbols(self: *Elf) !void {
    const object = &(self.internal_object orelse return);
    self.dynamic_index = try object.addSyntheticGlobal("_DYNAMIC", self);
    self.init_array_start_index = try object.addSyntheticGlobal("__init_array_start", self);
    self.init_array_end_index = try object.addSyntheticGlobal("__init_array_end", self);
    self.fini_array_start_index = try object.addSyntheticGlobal("__fini_array_start", self);
    self.fini_array_end_index = try object.addSyntheticGlobal("__fini_array_end", self);
    self.got_index = try object.addSyntheticGlobal("_GLOBAL_OFFSET_TABLE_", self);
    try object.resolveSymbols(self);
}

fn checkDuplicates(self: *Elf) void {
    for (self.objects.items) |object| {
        object.checkDuplicates(self);
    }
}

fn checkUndefined(self: *Elf) void {
    for (self.objects.items) |object| {
        object.checkUndefined(self);
    }
}

fn setSymtab(self: *Elf) !void {
    const symtab_sect_index = self.symtab_sect_index orelse return;

    // TODO: create the output symbol table
    // we need to traverse each object file, and save all locals first
    // next, traverse the set of globals and commit them to the output symbol table
    // optionally, we could exclude symbols that have hidden visibility but it is
    // not a must

    // Set the section sizes
    {
        const shdr = &self.sections.items(.shdr)[symtab_sect_index];
        shdr.sh_size = self.symtab.items.len * @sizeOf(elf.Elf64_Sym);
    }
    {
        const shdr = &self.sections.items(.shdr)[self.strtab_sect_index.?];
        shdr.sh_size = self.strtab.buffer.items.len;
    }
}

fn setShstrtab(self: *Elf) void {
    const shstrtab_sect_index = self.shstrtab_sect_index orelse return;
    const shdr = &self.sections.items(.shdr)[shstrtab_sect_index];
    shdr.sh_size = self.shstrtab.buffer.items.len;
}

fn writeAtoms(self: *Elf) !void {
    const slice = self.sections.slice();
    for (slice.items(.first_atom), 0..) |first_atom, i| {
        var atom_index = first_atom orelse continue;
        const shndx = @intCast(u16, i);
        const shdr = slice.items(.shdr)[shndx];

        if (shdr.sh_type == elf.SHT_NOBITS) continue;

        log.debug("writing atoms in '{s}' section", .{self.shstrtab.getAssumeExists(shdr.sh_name)});

        var buffer = try self.allocator.alloc(u8, shdr.sh_size);
        defer self.allocator.free(buffer);
        @memset(buffer, 0);

        var stream = std.io.fixedBufferStream(buffer);

        while (true) {
            const atom = self.getAtom(atom_index).?;
            const off = atom.value - shdr.sh_addr;
            log.debug("writing ATOM(%{d},'{s}') at offset 0x{x}", .{
                atom_index,
                atom.getName(self),
                shdr.sh_offset + off,
            });
            try stream.seekTo(off);
            try atom.resolveRelocs(self, stream.writer());

            if (atom.next) |next| {
                atom_index = next;
            } else break;
        }

        try self.file.pwriteAll(buffer, shdr.sh_offset);
    }
}

fn writeSyntheticSections(self: *Elf) !void {
    const gpa = self.allocator;
    // Currently, we only have .got to worry about.
    if (self.got_sect_index) |shndx| {
        const shdr = self.sections.items(.shdr)[shndx];
        var buffer = try std.ArrayList(u8).initCapacity(gpa, self.got_section.size());
        defer buffer.deinit();
        try self.got_section.write(self, buffer.writer());
        try self.file.pwriteAll(buffer.items, shdr.sh_offset);
    }
}

fn writeSymtab(self: *Elf) !void {
    const index = self.symtab_sect_index orelse return;
    const shdr = self.sections.items(.shdr)[index];
    log.debug("writing '.symtab' contents from 0x{x} to 0x{x}", .{
        shdr.sh_offset,
        shdr.sh_offset + shdr.sh_size,
    });
    try self.file.pwriteAll(mem.sliceAsBytes(self.symtab.items), shdr.sh_offset);
}

fn writeStrtab(self: *Elf) !void {
    const index = self.strtab_sect_index orelse return;
    const shdr = self.sections.items(.shdr)[index];
    log.debug("writing '.strtab' contents from 0x{x} to 0x{x}", .{
        shdr.sh_offset,
        shdr.sh_offset + shdr.sh_size,
    });
    try self.file.pwriteAll(self.strtab.buffer.items, shdr.sh_offset);
}

fn writeShStrtab(self: *Elf) !void {
    const index = self.shstrtab_sect_index orelse return;
    const shdr = self.sections.items(.shdr)[index];
    log.debug("writing '.shstrtab' contents from 0x{x} to 0x{x}", .{
        shdr.sh_offset,
        shdr.sh_offset + shdr.sh_size,
    });
    try self.file.pwriteAll(self.shstrtab.buffer.items, shdr.sh_offset);
}

fn writePhdrs(self: *Elf) !void {
    // TODO: work out at what offset we write the PHDRs in the file
    const phoff: usize = @sizeOf(elf.Elf64_Ehdr);
    const phdrs_size = self.phdrs.items.len * @sizeOf(elf.Elf64_Phdr);
    log.debug("writing program headers from 0x{x} to 0x{x}", .{ phoff, phoff + phdrs_size });
    try self.file.pwriteAll(mem.sliceAsBytes(self.phdrs.items), phoff);
}

fn writeShdrs(self: *Elf) !void {
    const size = self.sections.items(.shdr).len * @sizeOf(elf.Elf64_Shdr);
    log.debug("writing section headers from 0x{x} to 0x{x}", .{ self.shoff, self.shoff + size });
    try self.file.pwriteAll(mem.sliceAsBytes(self.sections.items(.shdr)), self.shoff);
}

fn writeHeader(self: *Elf) !void {
    // TODO: work out header fields
    var header = elf.Elf64_Ehdr{
        .e_ident = undefined,
        .e_type = elf.ET.EXEC,
        .e_machine = elf.EM.X86_64,
        .e_version = 1,
        .e_entry = if (self.entry_index) |index| self.getGlobal(index).value else 0,
        .e_phoff = @sizeOf(elf.Elf64_Ehdr),
        .e_shoff = self.shoff,
        .e_flags = 0,
        .e_ehsize = @sizeOf(elf.Elf64_Ehdr),
        .e_phentsize = @sizeOf(elf.Elf64_Phdr),
        .e_phnum = @intCast(u16, self.phdrs.items.len),
        .e_shentsize = @sizeOf(elf.Elf64_Shdr),
        .e_shnum = 0, // This will become @intCast(u16, self.sections.items(.shdr).len)
        .e_shstrndx = 0, // This will become self.shstrtab_sect_index.?
    };
    // Magic
    mem.copy(u8, header.e_ident[0..4], "\x7fELF");
    // Class
    header.e_ident[4] = elf.ELFCLASS64;
    // Endianness
    header.e_ident[5] = elf.ELFDATA2LSB;
    // ELF version
    header.e_ident[6] = 1;
    // OS ABI, often set to 0 regardless of target platform
    // ABI Version, possibly used by glibc but not by static executables
    // padding
    @memset(header.e_ident[7..][0..9], 0);
    log.debug("writing ELF header {} at 0x{x}", .{ header, 0 });
    try self.file.pwriteAll(mem.asBytes(&header), 0);
}

pub const AddSectionOpts = struct {
    name: [:0]const u8,
    type: u32 = elf.SHT_NULL,
    flags: u64 = 0,
    link: u32 = 0,
    info: u32 = 0,
    addralign: u64 = 0,
    entsize: u64 = 0,
};

pub fn addSection(self: *Elf, opts: AddSectionOpts) !u16 {
    const gpa = self.allocator;
    const index = @intCast(u16, self.sections.slice().len);
    try self.sections.append(gpa, .{
        .shdr = .{
            .sh_name = try self.shstrtab.insert(gpa, opts.name),
            .sh_type = opts.type,
            .sh_flags = opts.flags,
            .sh_addr = 0,
            .sh_offset = 0,
            .sh_size = 0,
            .sh_link = 0,
            .sh_info = opts.info,
            .sh_addralign = opts.addralign,
            .sh_entsize = opts.entsize,
        },
        .phdr = null,
        .first_atom = null,
        .last_atom = null,
    });
    return index;
}

pub fn getSectionByName(self: *Elf, name: [:0]const u8) ?u16 {
    for (self.sections.items(.shdr), 0..) |shdr, i| {
        const this_name = self.shstrtab.getAssumeExists(shdr.sh_name);
        if (mem.eql(u8, this_name, name)) return @intCast(u16, i);
    } else return null;
}

fn addSegment(self: *Elf, opts: struct {
    type: u32 = 0,
    flags: u32 = 0,
    @"align": u64 = 0,
    offset: u64 = 0,
    addr: u64 = 0,
    filesz: u64 = 0,
    memsz: u64 = 0,
}) !u16 {
    const index = @intCast(u16, self.phdrs.items.len);
    try self.phdrs.append(self.allocator, .{
        .p_type = opts.type,
        .p_flags = opts.flags,
        .p_offset = opts.offset,
        .p_vaddr = opts.addr,
        .p_paddr = opts.addr,
        .p_filesz = opts.filesz,
        .p_memsz = opts.memsz,
        .p_align = opts.@"align",
    });
    return index;
}

pub fn getSectionIndexes(self: *Elf, phdr_index: u16) struct { start: u16, end: u16 } {
    const start: u16 = for (self.sections.items(.phdr), 0..) |phdr, i| {
        if (phdr != null and phdr.? == phdr_index) break @intCast(u16, i);
    } else @intCast(u16, self.sections.slice().len);
    const end: u16 = for (self.sections.items(.phdr)[start..], 0..) |phdr, i| {
        if (phdr == null or phdr.? != phdr_index) break @intCast(u16, start + i);
    } else start;
    return .{ .start = start, .end = end };
}

fn getGotBaseAddress(self: *Elf) u64 {
    const shndx = self.got_sect_index orelse return 0;
    const shdr = self.sections.items(.shdr)[shndx];
    return shdr.sh_addr;
}

fn writeGotEntry(self: *Elf, entry: u32, writer: anytype) !void {
    if (self.got_sect_index == null) return;
    const sym = self.getGlobal(entry);
    try writer.writeIntLittle(u64, sym.value);
}

pub fn addAtom(self: *Elf) !Atom.Index {
    const index = @intCast(u32, self.atoms.items.len);
    const atom = try self.atoms.addOne(self.allocator);
    atom.* = .{};
    return index;
}

pub fn getAtom(self: Elf, atom_index: Atom.Index) ?*Atom {
    if (atom_index == 0) return null;
    assert(atom_index < self.atoms.items.len);
    return &self.atoms.items[atom_index];
}

const GetOrCreateGlobalResult = struct {
    found_existing: bool,
    index: u32,
};

pub fn getOrCreateGlobal(self: *Elf, name: [:0]const u8) !GetOrCreateGlobalResult {
    const gpa = self.allocator;
    const gop = try self.globals_table.getOrPut(gpa, name);
    if (!gop.found_existing) {
        const index = @intCast(u32, self.globals.items.len);
        const global = try self.globals.addOne(gpa);
        global.* = .{ .name = try self.string_intern.insert(gpa, name) };
        gop.value_ptr.* = index;
    }
    return .{
        .found_existing = gop.found_existing,
        .index = gop.value_ptr.*,
    };
}

pub fn getGlobal(self: *Elf, index: u32) *Symbol {
    assert(index < self.globals.items.len);
    return &self.globals.items[index];
}

pub fn warn(self: *Elf, comptime format: []const u8, args: anytype) void {
    self.warnings.ensureUnusedCapacity(self.allocator, 1) catch return;
    const msg = std.fmt.allocPrint(self.allocator, format, args) catch return;
    self.warnings.appendAssumeCapacity(msg);
}

pub fn fatal(self: *Elf, comptime format: []const u8, args: anytype) void {
    self.errors.ensureUnusedCapacity(self.allocator, 1) catch return;
    const msg = std.fmt.allocPrint(self.allocator, format, args) catch return;
    self.errors.appendAssumeCapacity(msg);
}

pub fn getAllWarningsAlloc(self: *Elf) !ErrorBundle {
    var bundle: ErrorBundle.Wip = undefined;
    try bundle.init(self.allocator);
    defer bundle.deinit();

    for (self.warnings.items) |msg| {
        try bundle.addRootErrorMessage(.{ .msg = try bundle.addString(msg) });
    }

    return bundle.toOwnedBundle("");
}

pub fn getAllErrorsAlloc(self: *Elf) !ErrorBundle {
    var bundle: ErrorBundle.Wip = undefined;
    try bundle.init(self.allocator);
    defer bundle.deinit();

    for (self.errors.items) |msg| {
        try bundle.addRootErrorMessage(.{ .msg = try bundle.addString(msg) });
    }

    return bundle.toOwnedBundle("");
}

fn renderWarningToStdErr(eb: ErrorBundle) void {
    std.debug.getStderrMutex().lock();
    defer std.debug.getStderrMutex().unlock();
    const stderr = std.io.getStdErr();
    return renderWarningToWriter(eb, stderr.writer()) catch return;
}

fn renderWarningToWriter(eb: ErrorBundle, writer: anytype) !void {
    for (eb.getMessages()) |msg| {
        try renderWarningMessageToWriter(eb, msg, writer, "warning", .cyan, 0);
    }
}

fn renderWarningMessageToWriter(
    eb: ErrorBundle,
    err_msg_index: ErrorBundle.MessageIndex,
    stderr: anytype,
    kind: []const u8,
    color: std.io.tty.Color,
    indent: usize,
) anyerror!void {
    const ttyconf = std.io.tty.detectConfig(std.io.getStdErr());
    const err_msg = eb.getErrorMessage(err_msg_index);
    try ttyconf.setColor(stderr, color);
    try stderr.writeByteNTimes(' ', indent);
    try stderr.writeAll(kind);
    try stderr.writeAll(": ");
    try ttyconf.setColor(stderr, .reset);
    const msg = eb.nullTerminatedString(err_msg.msg);
    if (err_msg.count == 1) {
        try stderr.print("{s}\n", .{msg});
    } else {
        try stderr.print("{s}", .{msg});
        try ttyconf.setColor(stderr, .dim);
        try stderr.print(" ({d} times)\n", .{err_msg.count});
    }
    try ttyconf.setColor(stderr, .reset);
    for (eb.getNotes(err_msg_index)) |note| {
        try renderWarningMessageToWriter(eb, note, stderr, "note", .white, indent + 4);
    }
}

pub fn reportWarningsAndErrors(self: *Elf) !void {
    var warnings = try self.getAllWarningsAlloc();
    defer warnings.deinit(self.allocator);
    if (warnings.errorMessageCount() > 0) {
        renderWarningToStdErr(warnings);
    }

    var errors = try self.getAllErrorsAlloc();
    defer errors.deinit(self.allocator);
    if (errors.errorMessageCount() > 0) {
        errors.renderToStdErr(.{ .ttyconf = std.io.tty.detectConfig(std.io.getStdErr()) });
        return error.LinkFail;
    }
}

pub fn reportWarningsAndErrorsAndExit(self: *Elf) void {
    self.reportWarningsAndErrors() catch process.exit(1);
}

fn fmtSections(self: *Elf) std.fmt.Formatter(formatSections) {
    return .{ .data = self };
}

fn formatSections(
    self: *Elf,
    comptime unused_fmt_string: []const u8,
    options: std.fmt.FormatOptions,
    writer: anytype,
) !void {
    _ = options;
    _ = unused_fmt_string;
    for (self.sections.items(.shdr), 0..) |shdr, i| {
        try writer.print("sect({d}) : {s} : @{x} ({x}) : align({x}) : size({x})\n", .{
            i,                 self.shstrtab.getAssumeExists(shdr.sh_name), shdr.sh_offset, shdr.sh_addr,
            shdr.sh_addralign, shdr.sh_size,
        });
    }
}

fn fmtSegments(self: *Elf) std.fmt.Formatter(formatSegments) {
    return .{ .data = self };
}

fn formatSegments(
    self: *Elf,
    comptime unused_fmt_string: []const u8,
    options: std.fmt.FormatOptions,
    writer: anytype,
) !void {
    _ = options;
    _ = unused_fmt_string;
    for (self.phdrs.items, 0..) |phdr, i| {
        const write = phdr.p_flags & elf.PF_W != 0;
        const read = phdr.p_flags & elf.PF_R != 0;
        const exec = phdr.p_flags & elf.PF_X != 0;
        var flags: [3]u8 = [_]u8{'_'} ** 3;
        if (exec) flags[0] = 'X';
        if (write) flags[1] = 'W';
        if (read) flags[2] = 'R';
        try writer.print("phdr({d}) : {s} : @{x} ({x}) : align({x}) : filesz({x}) : memsz({x})\n", .{
            i, flags, phdr.p_offset, phdr.p_vaddr, phdr.p_align, phdr.p_filesz, phdr.p_memsz,
        });
    }
}

fn dumpState(self: *Elf) std.fmt.Formatter(fmtDumpState) {
    return .{ .data = self };
}

fn fmtDumpState(
    self: *Elf,
    comptime unused_fmt_string: []const u8,
    options: std.fmt.FormatOptions,
    writer: anytype,
) !void {
    _ = options;
    _ = unused_fmt_string;
    for (self.objects.items, 0..) |object, object_id| {
        try writer.print("file({d}) : {s}\n", .{ object_id, object.name });
        try writer.print("{}{}\n", .{ object.fmtAtoms(self), object.fmtSymtab(self) });
    }
    if (self.internal_object) |object| {
        try writer.writeAll("linker-defined\n");
        try writer.print("{}\n", .{object.fmtSymtab(self)});
    }
    try writer.writeAll("GOT\n");
    try writer.print("{}\n", .{self.got_section});
    try writer.writeAll("Output sections\n");
    try writer.print("{}\n", .{self.fmtSections()});
    try writer.writeAll("Output segments\n");
    try writer.print("{}\n", .{self.fmtSegments()});
}

const std = @import("std");
const build_options = @import("build_options");
const builtin = @import("builtin");
const assert = std.debug.assert;
const elf = std.elf;
const fs = std.fs;
const log = std.log.scoped(.elf);
const state_log = std.log.scoped(.state);
const math = std.math;
const mem = std.mem;
const process = std.process;

const Allocator = mem.Allocator;
const Archive = @import("Archive.zig");
const Atom = @import("Atom.zig");
const Elf = @This();
const ErrorBundle = std.zig.ErrorBundle;
const InternalObject = @import("InternalObject.zig");
const Object = @import("Object.zig");
const StringTable = @import("strtab.zig").StringTable;
const Symbol = @import("Symbol.zig");
const SyntheticSection = @import("synthetic_section.zig").SyntheticSection;
